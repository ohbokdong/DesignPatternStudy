# Week 14

## Fly Weight Pattern(플라이웨이트 패턴)

- 동일한 것을 공유하여 사용하는 구조
- 동일한 것을 공유하여 메모리 사용량을 줄임
- 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화하는 디자인 패턴

 플라이웨이트 패턴은, 객체의 내부에서 참조하는 객체를 직접 만드는 것이 아니라, 없다면 만들고, 만들어져 있다면 객체를 공유하는 식으로 객체를 구성하는 방법이다. 이렇게 하기 위해 대부분 팩토리 메소드 패턴을 사용해 객체를 생성한다. 팩토리 메소드 안에서는 객체(Flyweight 객체)를 새로 생성한다. 이때 생성하는 객체가 내부적으로 참조하는 객체에 대해, 기존에 있는 객체를 참조만 하는 식으로 객체를 구성한다.  이렇게 하면 객체의 할당에 사용되는 메모리를 줄일 수 있을 뿐 아니라, 객체를 생성하는 시간도 들지 않게 된다.  플라이웨이트 패턴이 가장 많이 사용되는 사례는 바로 게임이다. 게임에는 많은 UI Widget 혹은 component들이 존재하는데, 대부분 일정한 패턴의 UI가 연속되는 경우가 많다. 이런 경우 플라이웨이트 패턴을 사용해 하나의 리소스를 여러 객체에서 공유해 사용하는 방식으로 프로그래밍이 작성된다.  
  
가장 대표적인 flyweight pattern중의 하나는 바로 자바의 String pool이다. 컴파일 타이밍에 스트링 객체로 선언되어있는 것들은 jvm heap 메모리의  permermant 영역으로 들어가게 된다. 만약 같은 내용의 String 객체가 선언되어있다고 하더라도 새로 permernant 영역에 String 객체에 써지는 것이 아니라 기존의 String객체를 참조하는 식으로 된다.   
  
```java
public class A {
   public String getStringA() {
      return "Hello";
   }
}

public class B {
   public String getStringB() {
      return "Hello";
   }
}
```
위 두 클래스의 getStringA() 와 getStringB()는 모두 같은 위치에 있는 "Hello" String을 리턴한다. 

#### 장점
- 객체의 수를 줄인다.
- 객체가 지속되는 경우에 필요한 메모리 및 저장장치의 양을 줄인다.
  
#### 단점
- 플라이 웨이트 패턴은 객체들을 공유하므로, 만약 객체들간 동일성 여부 테스트가 프로그램 내에서 사용될 경우에는 개념적으로 서로 다른 객체라 하더라도 동일한 것으로 판단할 수 있기 때문에 문제의 소지가 된다.  따라서 플라이 웨이트 패턴을 사용하는 프로그램은 객체들간 동일성 여부 테스트를 사용하지 않아야 한다. 

#### 사용시기
- 응용프로그램이 많은 수의 객체를 사용하는 경우
- 물체의 수량으로 인해 저장비용이 높은 경우
- 응용프로그램이 객체 ID에 의존하지 않는 경우

-------------------------------

## Memento(메멘토 패턴)

- 상태를 저장하는 구조
- 객체를 이전 상태에 되돌리는 기능(rollback)을 제공하는 디자인 패턴
- originator와 caretaker
- originator: 내부 상태를 가지는 객체
- caretaker: originator의 변경을 되돌리는 능력을 가지는 객체

메맨토 패턴은 객체의 상태 정보를 가지는 클래스를 따로 생성하여, 객체의 상태를 저장하거나 이전 상태로 복원할 수 있게 해주는 패턴이다. 메멘토 패턴은 바둑, 오목, 체스 등의 보드게임 등에서 '무르기' 기능을 구현할 때 사용되기도 한다.  
  
단, 이전 상태의 객체를 저장하기 위한 Originator가 클 경우 많은 메모리가 필요하다.  
