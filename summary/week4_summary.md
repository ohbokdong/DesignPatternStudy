# Week 4

## 팩토리 패턴 (Factory Pattern)

* **구상클래스**
  * 추상 클래스와 반대되는 개념으로 이해
  * 추상 클래스 <--> 구현을 제공하지 않는 operation(method)을 갖는 클래스
  * 구상클래스 <--> 모든 operation이 구현을 제공하는 클래스
  * 즉, 어떤 클래스가 추상 클래스인데, 그 클래스를 상속받아 모두 구현해놓은 자식 클래스 또한 "구상 클래스"라 할 수 있다. 
  * **구상 객체**는 new를 사용하여 구상 클래스의 인스턴스를 만드는 것. 인터페이스가 아닌 특정 구현을 사용하는 것.



## 팩토리 메소드 패턴
* **객체 생성**을 캡슐화 하는 것.
  * 어떤 클래스의 인스턴스를 만들어내는 일은 서브클래스에서 처리
    
* **팩토리 메소드 패턴**의 **원칙** 가이드라인
  * 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 않는다.
  * 구상 클래스에서 유도된 클래스를 만들지 않는다.
  * 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드하지 않는다.

1. **바뀌는 부분은 캡슐화한다**
2. **상속보다는 구성을 활용한다**
3. **구현이 아닌 인터페이스에 맞춰 프로그래밍을 한다**

## 스트레티지 패턴(Strategy Pattern)

* **알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다.**
* **스트래티지 패턴을 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.**	
* **스트래티지 패턴을 사용한 클래스다이어그램 예시**
  * Duck이 FlyBehavior와 QuackBehavior를 갖는 has-a 관계
  * FlyBehavitor를 구현하는 FlyWithWings와 FlyNoWay는 다형성을 이용한 is-a 관계

![01](https://github.com/younggeun0/DesignPatternStudy/blob/master/summary/img/week1_01.jpg?raw=true)

## 1장 요약

* **디자인 패턴은 객체지향 시스템 구축 방법들**
  * 패턴은 검증받은 객체지향 경험의 산물
  * **패턴은 발명되는 것이 아니라 발견되는 것**
* 객체지향 기초지식만 가지고는 훌륭한 객체지향 디자이너가 될 수 없음
  * **훌륭한 객체지향 디자인이란 재사용성, 확장성, 관리의 용이성을 갖춰야 함**
  * **패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공해 줌**
* 대부분의 패턴과 원칙은 소프트웨어의 변경 문제와 관련되어 있음
  * 대부분의 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공
  * 많은 경우 시스템에서 바뀌는 부분을 골라내 캡슐화 시켜야 함
* **패턴은 다른 개발자들과의 의사소통의 가치를 극대화 시킬 수 있는 전문 용어 역할을 함**
* **디자인 패턴은 라이브러리보다 높은 단계**
  * 디자인 패턴은 클래스와 객체를 구성하여 어떤 문제를 해결하는 방법을 제공, 그러한 디자인을 특정 앱에 맞게 적용하는 것은 개발자 몫
  * 프레임워크나 라이브러리는 디자인 패턴이 아님, 개발자들이 각자의 코드에 링크시켜 쓸 수 있는 특정 구현을 제공할 뿐
    * 라이브러리나 프레임워크를 구현하는 과정에서 디자인 패턴을 사용하는 경우도 있음
* **관리가 용이한 객체지향 시스템을 만드는 비결 가운데 하나가 바로 나중에 어떻게 바뀔 것인지에 대해 생각해 보는 것**
