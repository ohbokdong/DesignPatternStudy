# Week 9 보충

## 자료구조 트리 
* 데이터 사이의 계층 관계를 나타내는 자료구조
* 노드(node)와 가지(edge)로 구성되며 노드는 가지를 통해 다른 노드와 연결되어 있음.
* **O는 노드, ㅡ는 가지**를 나타냄.  
  
![06](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_06.png)  
붉은색으로 표시한 부분은 서브 트리라고 부르며, 이 때 X는 서브트리의 루트 역할을 한다.
  
### 트리 관련 용어

#### 루트
트리의 가장 윗부분에 위치하는 노드. 하나의 트리에는 하나의 루트가 있음.

#### 리프
가지가 없어 더 이상 뻗어나갈 수 없는 마지막 노드.  
> 다른 용어로는 끝 노드(terminal node) 또는 바깥 노드(external node)라고도 함. 

#### 안쪽 노드
리프를 제외한 노드. 루트 또한 안쪽 노드라 함.
> 다른 용어로는 끝이 아닌 노드 (non-terminal node)라고도 함.

#### 자식
어떤 노드로부터 가지로 연결된 아래쪽 노드. 노드는 자식을 여러개 가질 수 있음.  
위 이미지의 경우 X는 2개, Y는 3개의 자식을 가지고 있음.
> 리프는 자식을 가질 수 없음.

#### 부모
어떤 노드에서 가지로 연결된 위쪽 노드. 노드는 1개의 부모를 가짐.  
위 이미지의 경우 Y의 부모는 X.
> 루트는 부모를 가질 수 없음.

#### 형제
같은 부모를 가지는 노드.

#### 조상
어떤 노드에서 가지로 연결된 위쪽 노드 모두를 조상(ancestor)이라 함.

#### 자손
어떤 노드에서 가지로 연결된 아래쪽 노드 모두를 자손(descendant)이라 함.

#### 레벨
루트로부터 얼마나 떨어져 있는지에 대한 값을 레벨(level)이라 함.  
루트의 레벨은 0이고 루트로부터 가지가 하나씩 아래로 뻗어나갈 때마다 레벨이 1씩 늘어남.

#### 차수
노드가 갖는 자식의 수를 차수(degree)라 함. 위 이미지의 경우 X의 차수는 2, Y의 차수는 3.  
**모든 노드의 차수가 n 이하인 트리를 n진 트리**라고 함. 위 이미지의 경우 모든 노드의 자식이 3 이하 이므로 3진 트리임.

#### 높이
루트로부터 가장 멀리 떨어진 리프까지의 거리(리프 레벨의 최대값). 위 이미지의 경우 트리의 높이는 3.

### 서브트리
트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리. 위 이미지의 경우 붉게 표시한 부분은 X를 루트로 하는 서브 트리.

#### 널 트리
노드, 가지가 없는 트리를 널 트리(null tree)라고 함.

#### 순서 트리와 무순서 트리
![07](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_07.png)  
형제 노드의 순서가 있는지 없는지에 따라 트리를 두 종류로 분류. 형제 노드의 순서를 따지면 순서 트리(ordered tree), 따지지 않으면 무순서 트리(unordered tree)라고 함. 위 이미지의 경우 순서 트리로 보면 다른 트리지만, 무순서 트리로 보면 같은 트리라고 할 수 있음.

### 순서 트리의 탐색 방법

#### 너비 우선 탐색
![08](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_08.png)  

낮은 레벨에서 시작해 좌 => 우 방향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려가는 방법.
```
A > B > C > D > E > F > G > H > I > J > K > L
```

#### 깊이 우선 탐색
![09](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_09.png)  

리프까지 내려가면서 검색하는 것을 우선순위로 하는 탐색 방법.  
리프에 도달해 더 이상 검색을 진행할 곳이 없는 경우에는 부모에게 돌아가며 그런 다음 다시 자식 노드로 내려감.  
두 자식 가운데 한쪽(또는 양쪽)이 없으면 노드를 지나가는 횟수가 줄어들겠지만 노드를 지나가는 최대값은 3회.
> 친구의 집을 지나치는 것과 직접 방문하는 것은 다름. 이와 마찬가지로 깊이 우선 탐색도 지나가는 것과 방문하는 것을 구분해서 생각해야 함.

### 깊이 우선 탐색의 세 종류

#### 전위 순회(Preorder)
```
노드방문 > 왼쪽 자식 > 오른쪽 자식
A > B > D > H > E > I > J > C > F > K > L > G
```

#### 중위 순회(Inorder)
```
왼쪽 자식 > 노드 방문 > 오른쪽 자식
H > D > B > I > E > J > A > K > F > L > C > G
```

#### 후위 순회(Postorder)
```
왼쪽 자식 > 오른쪽 자식 > (돌아와)노드 방문
H > D > I > J > E > B > K > L > F > G > C > A
```

### 이진트리와 이진검색트리

#### 이진트리
노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리를 이진트리(binary tree)라고 함. 이 때 **각 노드의 자식은 2명 이하만 유지**해야 함.
![10](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_10.png)  

이진트리의 특징은 왼쪽 자식과 오른쪽 자식을 구분함. 예를 들어 위 이미지의 노드 B의 왼쪽 자식은 D, 오른쪽 자식은 E. 이 때 왼쪽 자식을 다시 루트로 하는 서브 트리를 왼쪽 서브 트리(left subtree), 오른쪽 자식을 다시 루트로 하는 서브트리를 오른쪽 트리(right subtree)라고 함.

#### 완전이진트리
루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져 있는 이진트리를 완전이진트리(complete binary tree)라고 함.  
**완전이진트리의 조건**
1. 마지막 레벨을 제외한 레벨은 노드를 가득 채운다.
2. 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없다.
![11](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_11.png)  

위 이미지와 같이 완전이진트리에서 너비 우선 탐색을 하며 각 노드에 0, 1, 2 … 값을 주면  
배열에 저장하는 인덱스와 일대일로 대응한다는 것을 알 수 있음.

높이가 k인 완전 이진트리가 가질 수 있는 노드의 최대값은 **2<sup>k+1</sup> - 1개**이며 따라서 n개의 노드를 저장할 수 있는 완전이진트리의 높이는 log n이다.

#### 이진검색트리
이진검색트리(binary search tree)는 이진트리가 다음조건을 만족하면 된다.
1. 어떤 노드 N을 기준으로 왼쪽 서브 트리 노드의 모든 키 값은 노드 N의 키 값보다 작아야 한다.
2. 오른쪽 서브 트리 노드의 키 값은 노드 N의 키 값보다 커야 한다.
3. 같은 키 값을 갖는 노드는 없음.
![12](https://github.com/ohbokdong/DesignPatternStudy/blob/master/summary/img/week9_12.png)  

위 그림은 이진 검색트리를 구현한 예. 여기서 노드 5를보면 왼쪽 서브 트리 노드(4, 1)는 모두 5보다 작다. 그리고 오른쪽 서브 트리 노드(7, 6, 9)는 모두 5보다 크다. 이때 이진검색트리를 중위 순회(Inorder)하면 다음과 같이 키 값의 오름차순으로 노드를 얻을 수 있다.
```
1 > 4 > 5 > 6 > 7 > 9 > 11 > 12 > 13 > 14 > 15 > 18
```
